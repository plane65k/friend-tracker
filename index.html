<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Friend Tracker Compass Precise</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
html, body { height: 100%; margin: 0; font-family: Arial, sans-serif; background:#f5f5f5; }
#map { height: 100%; width: 100%; display:none; }
#startButton {
  position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  padding:18px 28px; font-size:18px; z-index:1000;
  border-radius:12px; background:#1a73e8; color:white; border:none; cursor:pointer;
  box-shadow:0 4px 12px rgba(0,0,0,0.25);
}
#arrowUI {
  position:absolute; top:15px; left:50%; transform:translateX(-50%);
  z-index:1000; background:rgba(255,255,255,0.95); border-radius:10px;
  padding:12px 18px; text-align:center; font-weight:bold; font-size:16px;
  box-shadow:0 4px 12px rgba(0,0,0,0.2);
  display:none;
}
#arrowImage {
  width:60px; height:60px; display:block; margin:0 auto 5px;
  transform-origin: 50% 50%; transition: transform 0.1s linear;
}
#distance { font-size:18px; }
#friendsList {
  position:absolute; top:15px; right:15px; z-index:1000;
  background:rgba(255,255,255,0.95); border-radius:10px;
  padding:12px; max-height:300px; overflow-y:auto;
  box-shadow:0 4px 12px rgba(0,0,0,0.2); display:none;
  min-width:200px;
}
.friend-item {
  padding:8px 12px; margin:5px 0; border-radius:6px;
  cursor:pointer; transition:background 0.2s;
}
.friend-item:hover { background:#f0f0f0; }
.friend-item.selected {
  background:#1a73e8; color:white;
}
#friendsHeader {
  font-weight:bold; margin-bottom:8px; padding-bottom:8px;
  border-bottom:1px solid #e0e0e0;
}
</style>
</head>
<body>

<button id="startButton">Start Tracking Location</button>
<div id="map"></div>
<div id="arrowUI">
  <img id="arrowImage" src="https://cdn-icons-png.flaticon.com/512/32/32339.png" alt="arrow">
  <div id="distance">0 m</div>
</div>
<div id="friendsList">
  <div id="friendsHeader">Select a Friend</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

document.addEventListener('DOMContentLoaded', async () => {

  const startButton = document.getElementById('startButton');
  const arrowUI = document.getElementById('arrowUI');
  const arrowImage = document.getElementById('arrowImage');
  const distanceEl = document.getElementById('distance');
  const friendsList = document.getElementById('friendsList');

  startButton.addEventListener('click', async () => {
    // Ask iOS for motion/compass permission
    if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
      try {
        const resp = await DeviceOrientationEvent.requestPermission();
        if (resp !== 'granted') { 
          alert('Compass permission denied. Direction features will not work.'); 
        }
      } catch (e) { 
        console.error(e); 
        alert('Error requesting compass permission: ' + e.message);
      }
    }

    if (!navigator.geolocation) { 
      alert('Geolocation not supported'); 
      return; 
    }

    // Request location permission
    navigator.geolocation.getCurrentPosition(
      () => {
        // Location permission granted
        startTracking();
      },
      (error) => {
        alert('Location permission denied or error: ' + error.message);
        return;
      },
      { enableHighAccuracy: true }
    );
  });

  function startTracking() {
    startButton.style.display = 'none';
    document.getElementById('map').style.display = 'block';
    arrowUI.style.display = 'block';
    friendsList.style.display = 'block';

    // Supabase setup with your provided credentials
    const supabaseUrl = 'https://ngyjswujmvkqmqlymrhu.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5neWpzd3VqbXZrcW1xbHltcmh1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwNzQ1NTEsImV4cCI6MjA3NDY1MDU1MX0.DZ7Nzbms9LLNgIjco9viGPD5rRjlKlbpA75kaN2mp0w';
    const supabase = createClient(supabaseUrl, supabaseKey);

    let userId = localStorage.getItem('friendtrack_userId');
    if (!userId) {
      userId = 'user-' + Math.floor(Math.random() * 1000000);
      localStorage.setItem('friendtrack_userId', userId);
    }

    const map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    let myMarker = null;
    let myHeading = 0;
    let compassLine = null;
    let routeLine = null;
    let firstUpdate = true;
    let friendMarkers = {};
    let selectedFriend = null;
    let friendListItems = {};

    function deg2rad(d){ return d*Math.PI/180; }
    function rad2deg(r){ return r*180/Math.PI; }

    function haversine(lat1, lon1, lat2, lon2){
      const R = 6371000;
      const dLat = deg2rad(lat2 - lat1);
      const dLon = deg2rad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(deg2rad(lat1))*Math.cos(deg2rad(lat2))*Math.sin(dLon/2)**2;
      return R*2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function bearing(lat1, lon1, lat2, lon2){
      const y = Math.sin(deg2rad(lon2-lon1))*Math.cos(deg2rad(lat2));
      const x = Math.cos(deg2rad(lat1))*Math.sin(deg2rad(lat2)) -
                Math.sin(deg2rad(lat1))*Math.cos(deg2rad(lat2))*Math.cos(deg2rad(lon2-lon1));
      return (rad2deg(Math.atan2(y,x))+360)%360;
    }

    function updateMyMarker(lat, lng){
      if(!myMarker){
        myMarker = L.circleMarker([lat,lng], {
          radius:10, color:'#1a73e8', fillColor:'#1a73e8', fillOpacity:0.9
        }).addTo(map);
        myMarker.bindPopup("You").openPopup();
      } else {
        myMarker.setLatLng([lat,lng]);
      }

      if(firstUpdate){ map.setView([lat,lng], 16); firstUpdate=false; }

      // Update direction line (infinite)
      const distance = 1000000; // huge distance for "infinite" line
      const rad = deg2rad(myHeading);
      const lat2 = lat + (distance/111111) * Math.cos(rad); // approx conversion meters->degrees
      const lng2 = lng + (distance/111111) * Math.sin(rad);

      if(!compassLine){
        compassLine = L.polyline([[lat,lng],[lat2,lng2]], {color:'#1a73e8',weight:3}).addTo(map);
      } else {
        compassLine.setLatLngs([[lat,lng],[lat2,lng2]]);
      }

      // Update route to friend
      if(selectedFriend){
        updateRouteToFriend(lat, lng);
        updateArrowDirection(lat, lng);
      }
    }

    function updateRouteToFriend(myLat, myLng) {
      if (!selectedFriend) return;
      
      // Create or update the route line
      const routeCoordinates = [
        [myLat, myLng],
        [selectedFriend.lat, selectedFriend.lng]
      ];
      
      if(!routeLine){
        routeLine = L.polyline(routeCoordinates, {
          color: '#4CAF50',
          weight: 4,
          opacity: 0.7,
          dashArray: '10, 10'
        }).addTo(map);
      } else {
        routeLine.setLatLngs(routeCoordinates);
      }
    }

    function updateArrowDirection(myLat, myLng) {
      if (!selectedFriend) return;
      
      const targetBearing = bearing(myLat, myLng, selectedFriend.lat, selectedFriend.lng);
      const diff = (targetBearing - myHeading + 360) % 360;
      arrowImage.style.transform = `rotate(${diff}deg)`;
      const dist = haversine(myLat, myLng, selectedFriend.lat, selectedFriend.lng);
      distanceEl.textContent = dist>1000 ? (dist/1000).toFixed(2)+' km' : Math.round(dist)+' m';
    }

    function updateFriendMarker(data){
      if(data.user_id===userId) return;
      
      const pos=[data.lat,data.lng];
      if(!friendMarkers[data.user_id]){
        friendMarkers[data.user_id] = L.circleMarker(pos,{
          radius:8,color:'#e81a1a',fillColor:'#e81a1a',fillOpacity:0.9
        }).addTo(map);
        
        // Add popup with user info
        friendMarkers[data.user_id].bindPopup(`Friend: ${data.user_id}<br>Last updated: ${new Date(data.updated_at).toLocaleTimeString()}`);
        
        // Add click event to select this friend
        friendMarkers[data.user_id].on('click',()=>{ 
          selectFriend(data);
        });
        
        // Add to friends list
        addFriendToList(data);
      } else {
        friendMarkers[data.user_id].setLatLng(pos);
        // Update friend list item
        updateFriendListItem(data);
      }
      
      if(selectedFriend && selectedFriend.user_id===data.user_id) {
        selectedFriend = data;
        if (myMarker) {
          const myPos = myMarker.getLatLng();
          updateRouteToFriend(myPos.lat, myPos.lng);
          updateArrowDirection(myPos.lat, myPos.lng);
        }
      }
    }

    function addFriendToList(data) {
      const friendItem = document.createElement('div');
      friendItem.className = 'friend-item';
      friendItem.id = `friend-${data.user_id}`;
      friendItem.textContent = `Friend: ${data.user_id.substring(0, 8)}...`;
      friendItem.addEventListener('click', () => {
        selectFriend(data);
      });
      friendsList.appendChild(friendItem);
      friendListItems[data.user_id] = friendItem;
    }

    function updateFriendListItem(data) {
      if (friendListItems[data.user_id]) {
        friendListItems[data.user_id].textContent = `Friend: ${data.user_id.substring(0, 8)}... (${new Date(data.updated_at).toLocaleTimeString()})`;
      }
    }

    function selectFriend(data) {
      // Deselect previously selected friend
      if (selectedFriend && friendListItems[selectedFriend.user_id]) {
        friendListItems[selectedFriend.user_id].classList.remove('selected');
      }
      
      // Select new friend
      selectedFriend = data;
      if (friendListItems[data.user_id]) {
        friendListItems[data.user_id].classList.add('selected');
      }
      
      // Update route and arrow direction
      if (myMarker) {
        const myPos = myMarker.getLatLng();
        updateRouteToFriend(myPos.lat, myPos.lng);
        updateArrowDirection(myPos.lat, myPos.lng);
      }
      
      // Center map on selected friend
      map.setView([data.lat, data.lng], map.getZoom());
      
      // Open popup
      if (friendMarkers[data.user_id]) {
        friendMarkers[data.user_id].openPopup();
      }
    }

    async function writeLocation(lat,lng,heading){
      await supabase.from('locations').upsert({user_id:userId,lat,lng,heading,updated_at:new Date()});
    }

    window.addEventListener('beforeunload', async()=>{
      await supabase.from('locations').delete().eq('user_id',userId);
    });

    // Subscribe to updates
    supabase.channel('locations_channel')
      .on('postgres_changes',{event:'*',schema:'public',table:'locations'},payload=>{
        if (payload.new) {
          updateFriendMarker(payload.new);
        }
      })
      .subscribe();

    // GPS
    navigator.geolocation.watchPosition(pos=>{
      const lat=pos.coords.latitude, lng=pos.coords.longitude;
      updateMyMarker(lat,lng);
      writeLocation(lat,lng,myHeading);
    }, err=>console.error(err), {enableHighAccuracy:true, maximumAge:0, timeout:30000});

    // Compass (Android + iOS)
    window.addEventListener('deviceorientation', e=>{
      let heading;
      if(typeof e.webkitCompassHeading!=='undefined'){ // iOS
        heading = e.webkitCompassHeading;
      } else if(e.alpha!=null){ // Android
        heading = 360 - e.alpha; // convert to compass bearing
      }
      if(heading!=null){
        myHeading = heading;
        if(myMarker){
          const lat=myMarker.getLatLng().lat, lng=myMarker.getLatLng().lng;
          const distance=1000000;
          const rad=deg2rad(myHeading);
          const lat2 = lat + (distance/111111) * Math.cos(rad);
          const lng2 = lng + (distance/111111) * Math.sin(rad);
          compassLine.setLatLngs([[lat,lng],[lat2,lng2]]);
          
          // Update arrow direction if a friend is selected
          if(selectedFriend){
            updateArrowDirection(lat, lng);
          }
        }
      }
    });

    // Poll + cleanup - Auto delete locations older than 30 seconds
    setInterval(async()=>{
      const {data,error}=await supabase.from('locations').select('*');
      if(data) data.forEach(d=>updateFriendMarker(d));
      const cutoff=new Date(Date.now()-30000).toISOString();
      await supabase.from('locations').delete().lt('updated_at',cutoff);
    },1000);

  }

});
</script>
</body>
</html>
