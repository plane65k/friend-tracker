<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Friend Tracker</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  body { margin:0; font-family: "Inter", sans-serif; background:#f0f2f5; color:#333; }
  #map { height: 80vh; width: 100%; }
  #arrow { font-size:48px; text-align:center; width:60px; height:60px; line-height:60px;
    border-radius:50%; background:#fff; border:2px solid #4caf50; position:fixed; top:10px;
    left:50%; transform:translateX(-50%); z-index:1000; }
  #distance { text-align:center; font-size:16px; margin-top:75px; font-weight:bold; }
  #controls { display:flex; justify-content:space-around; align-items:center; padding:10px;
    background:#fff; border-top:1px solid #ddd; }
  #friendList { flex:1; padding:5px; }
  .friend-btn { background:#4caf50; border:none; padding:8px 12px; border-radius:8px;
    color:#fff; cursor:pointer; margin:4px; transition:0.2s; }
  .friend-btn:hover { background:#45a049; }
</style>
</head>
<body>
<div id="map"></div>
<div id="arrow">↑</div>
<div id="distance">Distance: -- m</div>
<div id="controls">
  <div id="friendList"></div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

const supabaseUrl = "https://ngyjswujmvkqmqlymrhu.supabase.co";
const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5neWpzd3VqbXZrcW1xbHltcmh1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwNzQ1NTEsImV4cCI6MjA3NDY1MDU1MX0.DZ7Nzbms9LLNgIjco9viGPD5rRjlKlbpA75kaN2mp0w";
const supabase = createClient(supabaseUrl, supabaseKey);

const userId = "user_" + Math.random().toString(36).substring(2,9);
let map = L.map("map").setView([0,0],2);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{attribution:"© OpenStreetMap contributors"}).addTo(map);

let userMarker=null, headingLine=null, friends={}, targetFriend=null, currentHeading=0;
let firstLocationUpdate = true;

// Request location with high accuracy
async function requestLocation(){
  if(!navigator.geolocation){ alert("Geolocation not supported"); return; }
  navigator.geolocation.watchPosition(async pos => {
    const { latitude, longitude } = pos.coords;

    if(!userMarker){
      userMarker = L.circleMarker([latitude,longitude],{radius:10,color:"blue",fillColor:"blue",fillOpacity:1}).addTo(map);
      map.setView([latitude,longitude],17);
    } else userMarker.setLatLng([latitude,longitude]);

    // Heading line
    if(headingLine) map.removeLayer(headingLine);
    const dest = computeDestinationPoint({lat:latitude,lng:longitude}, currentHeading, 20000000);
    headingLine = L.polyline([[latitude,longitude],[dest.lat,dest.lng]], {color:"blue",weight:2}).addTo(map);

    await supabase.from("locations").upsert({id:userId, lat:latitude, lng:longitude, updated_at: new Date().toISOString()});

    // Update friend markers
    Object.values(friends).forEach(f=>f.marker && f.marker.setLatLng([f.lat,f.lng]));
  }, err=>console.error(err), {enableHighAccuracy:true, maximumAge:500, timeout:10000});
}

// Compass handling (iOS + Android)
function handleOrientation(event){
  let heading;
  if(event.webkitCompassHeading !== undefined) heading = event.webkitCompassHeading;
  else heading = 360 - event.alpha;
  currentHeading = heading;
}

// Request compass permission
async function requestCompass(){
  if(window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === "function"){
    const resp = await DeviceOrientationEvent.requestPermission().catch(console.error);
    if(resp==="granted") window.addEventListener("deviceorientation",handleOrientation);
  } else window.addEventListener("deviceorientationabsolute", handleOrientation);
}

// Load friends
async function loadFriends(){
  const { data } = await supabase.from("locations").select("*");
  renderFriends(data);
}

// Render friends
function renderFriends(rows){
  const friendListDiv = document.getElementById("friendList");
  friendListDiv.innerHTML="";
  rows.forEach(row=>{
    if(row.id===userId) return;
    if(!friends[row.id]){
      friends[row.id] = {
        marker: L.circleMarker([row.lat,row.lng],{radius:10,color:"red",fillColor:"red",fillOpacity:1}).addTo(map),
        lat: row.lat, lng: row.lng
      };
    } else { friends[row.id].lat=row.lat; friends[row.id].lng=row.lng; }
    const btn = document.createElement("button");
    btn.className="friend-btn"; btn.innerText=row.id;
    btn.onclick = ()=>targetFriend=row;
    friendListDiv.appendChild(btn);
  });
}

// Guide arrow & distance
setInterval(()=>{
  if(targetFriend && userMarker){
    const userLatLng = userMarker.getLatLng();
    const bearing = bearingTo([userLatLng.lat,userLatLng.lng],[targetFriend.lat,targetFriend.lng]);
    const diff = (bearing-currentHeading+360)%360;
    document.getElementById("arrow").style.transform=`translateX(-50%) rotate(${diff}deg)`;
    const dist = haversineDistance([userLatLng.lat,userLatLng.lng],[targetFriend.lat,targetFriend.lng]);
    document.getElementById("distance").innerText="Distance: "+Math.round(dist)+" m";
  }
},100);

// Refresh friend list every 2 sec
setInterval(loadFriends,2000);

// Cleanup old users every 30 sec
setInterval(async ()=>{
  const threshold = new Date(Date.now()-30_000).toISOString();
  const { error } = await supabase.from("locations").delete().lt("updated_at",threshold);
  if(error) console.error("Cleanup error:",error);
},30000);

// Haversine distance and bearing helpers
function haversineDistance(c1,c2){
  const R=6371e3, φ1=c1[0]*Math.PI/180, φ2=c2[0]*Math.PI/180;
  const Δφ=(c2[0]-c1[0])*Math.PI/180, Δλ=(c2[1]-c1[1])*Math.PI/180;
  const a=Math.sin(Δφ/2)**2+Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
  return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}
function bearingTo(from,to){
  const φ1=from[0]*Math.PI/180, φ2=to[0]*Math.PI/180, λ1=from[1]*Math.PI/180, λ2=to[1]*Math.PI/180;
  const y=Math.sin(λ2-λ1)*Math.cos(φ2), x=Math.cos(φ1)*Math.sin(φ2)-Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
  return (Math.atan2(y,x)*180/Math.PI+360)%360;
}
function computeDestinationPoint(start,brng,dist){
  const R=6371e3, δ=dist/R, θ=brng*Math.PI/180, φ1=start.lat*Math.PI/180, λ1=start.lng*Math.PI/180;
  const φ2=Math.asin(Math.sin(φ1)*Math.cos(δ)+Math.cos(φ1)*Math.sin(δ)*Math.cos(θ));
  const λ2=λ1+Math.atan2(Math.sin(θ)*Math.sin(δ)*Math.cos(φ1),Math.cos(δ)-Math.sin(φ1)*Math.sin(φ2));
  return {lat:φ2*180/Math.PI, lng:λ2*180/Math.PI};
}

// Initialize
requestLocation();
requestCompass();
loadFriends();
</script>
</body>
</html>
